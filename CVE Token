// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";


//NOTE: COMPATIBLE WITH OZ 5.0, do npm install @openzeppelin/contracts@5.0.0

contract TaxableToken is ERC20Burnable, Ownable {
    uint256 public transferTaxRate = 100; // Initially set to 1%
    uint256 public burnRate = 5000; // Initially set to 50% of the tax, in basis points
    uint256 public feeRate = 5000; // Initially set to 50% of the tax, in basis points
    address public feeAddress;
    mapping(address => bool) public isWhitelisted;

   constructor(address _feeAddress, uint totalSupply) ERC20("TaxToken", "Txt") Ownable(msg.sender) {
        require(_feeAddress != address(0), "Invalid fee address");
        feeAddress = _feeAddress;
        _mint(_msgSender(), totalSupply * 10 ** decimals());
        isWhitelisted[msg.sender] = true;
        isWhitelisted[_feeAddress] = true;
    }

    function setRates(uint256 _transferTaxRate, uint256 _burnRate, uint256 _feeRate) external onlyOwner {
        require(_transferTaxRate <= 100 && _burnRate + _feeRate == 10000, "Invalid rates");  // Ensures the sum of burnRate and feeRate is 100%
        transferTaxRate = _transferTaxRate;
        burnRate = _burnRate;
        feeRate = _feeRate;
    }

    function changeFeeAddress(address _address) external onlyOwner {
        require(_address != address(0), "Not to address(0)");
        feeAddress = _address;
    }

    function whitelistAddress(address _address, bool _whitelisted) external onlyOwner {
        isWhitelisted[_address] = _whitelisted;
    }

    //NOTE: mark OZ's _transfer function as virtual
    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {
        if (isWhitelisted[sender] || isWhitelisted[recipient]) {
            super._transfer(sender, recipient, amount);

        } else {
            uint256 taxAmount = amount * transferTaxRate / 10000;
            uint256 burnAmount = taxAmount * burnRate / 10000;
            uint256 feeAmount = taxAmount - burnRate;

            //NOTE: transfer fee from sender to feeAddress
            super._transfer(sender, feeAddress, feeAmount);
            //NOTE: transfer amount - tax from sender to recipient
            super._transfer(sender, recipient, amount - taxAmount);
            //NOTE: burn - must be done via _burn as transfer reverts for addres(0)
            _burn(sender, burnAmount);
        }
    }


}
